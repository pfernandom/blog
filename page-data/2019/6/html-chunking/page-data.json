{"componentChunkName":"component---src-templates-blog-post-js","path":"/2019/6/html-chunking/","result":{"data":{"site":{"siteMetadata":{"title":"Pedro's Tech Blog","author":"Pedro Marquez"}},"markdownRemark":{"id":"c3e2a613-7580-513a-b1bd-ecd182a01f7d","excerpt":"An Express server showcasing how HTML Chunking behaves, including blocking resources for Critical Rendering Path Why? I’ve read from multiple sources about HTML…","html":"<p>An Express server showcasing how HTML Chunking behaves, including blocking resources for Critical Rendering Path</p>\n<h2>Why?</h2>\n<p>I’ve read from multiple sources about HTML streaming (chunking) as a way to increase perceived page load performance, but it was very difficult for me to visualize it without an example.</p>\n<p>Most examples I’ve seen don’t exactly show what happens if one chunk takes considerably more time to be streamed than the previous, or what happens with multiple chunks with varying latencies.</p>\n<h3>Critical rendering Path</h3>\n<p>Another thing that was difficult to visualize to me were concepts like “blocking resources” like CSS and JS files; especially because HTML can be rendered in chunks one would think that CSS and JS can be chunked too.</p>\n<p>This project adds blocking CSS and JS scripts which finish loading after a timeout, specifically to verify what happens when we also stream blocking resources (<em>spoiler alert, they still block rendering of the HTML</em>)</p>\n<h2>How</h2>\n<p>Node’s Express allows writing chunks into a response stream using <a href=\"https://nodejs.org/api/stream.html#stream_writable_write_chunk_encoding_callback\">Node streams</a>, via its <code class=\"language-text\">response.write(chunk)</code> method.</p>\n<p>Using that method, we can simulate streaming multiple chunks with different latencies:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app.get('/', function (req, res) {\n  res.write('&lt;html>');\n  res.write('&lt;h1 class=\"my-text\">Hello&lt;/h1>');\n  \n  setTimeout(function() {\n    res.write(\"&lt;div>I took too long to load, like 5 seconds!&lt;/div>\");\n    res.write('&lt;/html>');\n    res.end();\n  }, 5000);\n});</code></pre></div>\n<p>Here, we stream first the openning tag <code class=\"language-text\">&lt;html></code> and the <code class=\"language-text\">&lt;h1></code> tag, then we wait for 5 seconds and we stream the rest of the document.</p>\n<p>In a real-world application, instead of a timeout we can do some costly operation like querying a DB. The browser will render the <code class=\"language-text\">&lt;h1></code> element and as more chunks are streamed, more parts of the page will be rendered.\nIn this way, we can get content to the user as fast as possible, without having to wait for those costly operations to finish before even sending the first byte of response.</p>\n<h3>Scripts and stylesheets</h3>\n<p>Using the same chunking technique, we can return JS and CSS files:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app.get('/styles.css', function (req, res) {\n  res.write('h1 { background-color:blue; }');\n  res.write('.my-text { background-color:yellow; }');\n  setTimeout(function() {\n    res.write(\" body { background-color: grey; }\");\n    res.end();\n  }, 4000);\n});\n\napp.get('/script.js', function (req, res) {\n  res.write('console.log(\"hello\");');\n  setTimeout(function() {\n    res.write('console.log(\"world\");');\n    res.end();\n  }, 4000);\n});</code></pre></div>\n<p>Unlike the chunked HTML, the browser will not execute/render each chunk as it gets it. It has to wait for the whole file to finish loading before it can continuing rendering the HTML which is declared after these <code class=\"language-text\">&lt;link></code> and <code class=\"language-text\">&lt;script></code> tags. So, even if we stream these resources, they will still block rendering.\nFor example, once the browser gets to the <code class=\"language-text\">&lt;script></code> tag for the <code class=\"language-text\">script.js</code> file we defined above, both <code class=\"language-text\">hello</code> and <code class=\"language-text\">world</code> will be printed in console at the same time, after the 4 seconds delay.</p>\n<p>Why is the browser not processing these files as they get streamed? This is out of the scope of this text, but from a high point of view is because <strong>the browser cannot correctly calculate styles or execute scripts without knowing the whole content of the file</strong>.\nTake as an example a JavaScript file. Thanks to <a href=\"https://www.w3schools.com/js/js_hoisting.asp\">hoisting</a>, declarations of JavaScript functions can be bellow their invocations:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">main();\n\nfunction main(){\n  console.log('Go main!');\n}</code></pre></div>\n<p>So, even if the browser browser is able to read the first line with <code class=\"language-text\">main()</code>, how would it know what to execute if it doesn’t have the function declaration yet?.</p>\n<h3>Fixing blocking resources</h3>\n<p>There are multiple ways to remove blocking CSS and JS, like inlining critical CSS and JS. It won’t change the blocking behavior of the <code class=\"language-text\">&lt;script></code> and <code class=\"language-text\">&lt;link></code> tags, but it will reduce the overhead of extra network requests and (hopefully) it will be smaller in content than the full, non-critical resources.</p>\n<ul>\n<li><a href=\"https://developers.google.com/speed/docs/insights/BlockingJS\">https://developers.google.com/speed/docs/insights/BlockingJS</a></li>\n</ul>\n<p>##Demo\n<img src=\"/54c282e15daa4dcc94ef0eb9821ef2fb/demo.gif\" alt=\"Gif showing the server running\"></p>","frontmatter":{"title":"Streaming HTML responses","date":"June 21, 2019","description":"How does HTML chunking work when streaming HTML files to the browser?","published":true}}},"pageContext":{"slug":"/2019/6/html-chunking/","previous":null,"next":{"fields":{"slug":"/2019/7/array-fill/"},"frontmatter":{"title":"Weird behavior for matrix created with Array.fill()","published":true}}}},"staticQueryHashes":["426816048","63159454"]}